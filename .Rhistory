install.packages("rmdformats")
install.packages("pretty_doc")
install.packages("prettydoc")
prettydoc::html_pretty()
help(prettydoc::html_pretty)
help("prettydoc::html_pretty")
help(html_pretty)
iris
d <- 3
d <- 3
head(iris)
var.endogena <- iris[,1]
var.explicativa <- iris[,2]
ajuste <- lm(var.endogena, var.explicativa)
datos <- data.frame(cbind(var.endogena, var.explicativa))
ajuste <- lm(var.endogena~var.explicativa, data = datos)
datos <- data.frame(cbind(var.endogena, var.explicativa))
ajuste <- lm(var.endogena~var.explicativa, data = datos)
ajuste
summary(ajuste)
res <- summary(ajuste)
attributes(res)
res$fstatistic
res$coefficients
# Contraste de regresión (H_0: beta_0 = 0):
resumen <- summary(ajuste)
contraste <- resumen$coefficients
r <- cor(var.endogena, var.explicativa)
r
resumen
r
# Coeficiente de determinación
R2 <- resumen$r.squared
R2.ajustado <- resumen$adj.r.squared
anova(ajuste)
# Podemos acceder al resultado del mismo contraste mediante anova:
contraste.regresion <- anova(ajuste)
contraste.regresion
leverage <- hatvalues(ajuste)
leverage
n.equivalente.datos <- 1/leverage
n.equivalente.datos
# AIC: Criterio de información de Akaike
# BIC: Criterio de Información Bayesiano
# Se introducirán con detalle en RLM. De momento nos quedamos con la
# idea de que cuánto menor su valor, mejor es el ajuste. En este caso:
AIC(ajuste)    # cuanto más pequeño, mejor (más ajustado)
library(DAAG)
# Validación cruzada
cvRes <- DAAG::CVlm(data=datos, form.lm=var.endogena~var.explicativa,
m=5, dots=FALSE, seed=29, plotit="Observed",
legend.pos="topleft",
printit=TRUE, main="")
# Validación cruzada
cvRes <- DAAG::CVlm(data=datos, form.lm=var.endogena~var.explicativa,
m=5, dots=FALSE, seed=29, plotit="Observed",
legend.pos="topleft",
printit = FALSE, main="")
# De cada uno de los "m" ajustes se calculan:
# "Sum of squares", o sea la suma de cuadrados de los residuos (SSR)
# "Mean square", o sea la suma de cuadrados promediada (MSSR)
# y "ms", el promedio de los "m" valores MSSR (en este caso ms=19)
# Esto último se puede obtener directamente con:
( MSSRcv  <- attr(cvRes, 'ms')  )
MSSR
MSSR <- SSR/gl.residuos           # media de SSR
coeficientes <- ajuste$coefficients
valores.ajustados <- ajuste$fitted.values
residuos <- ajuste$residuals
gl.residuos <- ajuste$df.residual # grados de libertad de los residuos
gl.modelo <- ajuste$rank          # grados de libertad del modelo
SSR <- sum(residuos^2)            # suma de residuos al cuadrado
MSSR <- SSR/gl.residuos           # media de SSR
leverage <- hatvalues(ajuste)
n.equivalente.datos <- 1/leverage
# De cada uno de los "m" ajustes se calculan:
# "Sum of squares", o sea la suma de cuadrados de los residuos (SSR)
# "Mean square", o sea la suma de cuadrados promediada (MSSR)
# y "ms", el promedio de los "m" valores MSSR (en este caso ms=19)
# Esto último se puede obtener directamente con:
( MSSRcv  <- attr(cvRes, 'ms')  )
MSSR
# Coeficiente de correlación lineal de Pearson estimado:
r <- cor(var.endogena, var.explicativa)
# ¿Es significativamente diferente de cero? H0:rho=0 vs H1:rho!=0
cor.test(var.endogena, var.explicativa, method = "pearson")
# Coeficiente de determinación
R2 <- resumen$r.squared
R2.ajustado <- resumen$adj.r.squared
# AIC, Criterio de Información de Akaike
AIC(ajuste)    # cuanto más pequeño, mejor (más ajustado)
# BIC, Criterio de Información Bayesiano (lo mismo, pero teniendo en cuenta
# el número de datos que tenemos)
BIC(ajuste)    # cuanto más pequeño, mejor (más ajustado)
# Validación cruzada
cvRes <- DAAG::CVlm(data=datos, form.lm=var.endogena~var.explicativa,
m=5, dots=FALSE, seed=29, plotit="Observed",
legend.pos="topleft",
printit = FALSE, main="")
# Validación cruzada
cvRes <- DAAG::CVlm(data=datos, form.lm=var.endogena~var.explicativa,
m=5, dots=FALSE, seed=29, plotit="Observed",
legend.pos="topleft",
printit = FALSE, main="")
Los símbolos pequeños son las predicciones por validación cruzada
mientras que los símbolos grandes corresponden a las observaciones
reales.
library(stats)
stats::AIC()
stats::AIC(ajuste)
# Validación cruzada
cvRes <- DAAG::CVlm(data=datos, form.lm=var.endogena~var.explicativa,
m=5, dots=FALSE, seed=29, #plotit="Observed",
legend.pos="topleft",
printit = FALSE, main="")
# Podemos acceder al resultado del mismo contraste mediante anova:
contraste.regresion <- anova(ajuste)
